/*
GoLexer - A Comprehensive Lexical Analyzer for Go
Author: Uthman Dev
GitHub: https://github.com/codetesla51/golexer
License: MIT

Clean Test Language Sample File
This file contains only tokens that are definitely supported
by the GoLexer library, guaranteed to produce ZERO lexical errors.

Use with: go run cmd/main.go test.lang
Expected result: 0 lexical errors
*/

// ===============================================
// KEYWORDS AND CONTROL FLOW
// ===============================================

let variable1 = 42;
const CONSTANT_VALUE = 100;

fn calculateSum(a, b) {
    return a + b;
}

int number;
float decimal;
string text;
bool flag;
char character;

if (condition) {
    while (counter < 10) {
        for (i = 0; i < length; i += 1) {
            if (breakCondition) {
                break;
            }
            if (skipCondition) {
                continue;
            }
        }
    }
} else {
    return false;
}

let truthValue = true;
let falseValue = false;
let emptyValue = null;

// ===============================================
// NUMBER FORMATS
// ===============================================

// Decimal integers
intZero = 0;
intSmall = 123;
intLarge = 999999;

// Decimal floats
floatPi = 3.14159;
floatZero = 0.0;
floatHalf = 0.5;
floatFortyTwo = 42.0;

// Scientific notation
sciBasic = 1e5;
sciDecimal = 2.5e10;
sciNegExp = 3.14e-2;
sciPosExp = 1.5e+8;
sciUpperE = 1E3;
sciUpperDecimal = 6.02E23;
sciUpperNeg = 9.8E-2;
sciUpperPos = 1.23E+4;

// Hexadecimal numbers
hexSmall = 0xa;
hexMed = 0xff;
hexLarge = 0xFF;
hexMixed = 0xaBcD;
hexUpperPre = 0X1A2B;

// Binary numbers
binSmall = 0b1;
binMed = 0b1010;
binLarge = 0B1111;
binLong = 0b11110000;

// Octal numbers
octModern = 0o777;
octModernUp = 0O755;
octTraditional = 0755;
octSmall = 07;

// ===============================================
// STRING LITERALS
// ===============================================

// Basic strings
str1 = "hello world";
str2 = "";
str3 = "single";

// Escaped strings
str4 = "He said \"Hello\"";
str5 = "Path: C:\\Users\\Name";
str6 = "Line1\nLine2\tTabbed";
str7 = "Bell\a Back\b Feed\f";
str8 = "Vertical\v Null\0";

// Hex escapes in strings
str9 = "Letter: \x41";
str10 = "Newline: \x0A";
str11 = "Space: \x20";

// Raw strings
raw1 = `This is raw`;
raw2 = `No escape: \n \t`;
raw3 = `C:\Windows\file.exe`;
raw4 = `Multi
line
raw`;

// ===============================================
// CHARACTER LITERALS
// ===============================================

char1 = 'a';
char2 = 'Z';
char3 = '0';
char4 = '9';
char5 = '@';

charEsc1 = '\n';
charEsc2 = '\t';
charEsc3 = '\r';
charEsc4 = '\\';
charEsc5 = '\'';
charEsc6 = '"';

charCtrl1 = '\a';
charCtrl2 = '\b';
charCtrl3 = '\f';
charCtrl4 = '\v';
charCtrl5 = '\0';

charHex1 = '\x41';
charHex2 = '\x20';
charHex3 = '\x7F';

// ===============================================
// IDENTIFIERS
// ===============================================

validIdent = 42;
_underscore = "value";
CamelCase = true;
snake_case = false;
mixed123 = null;
_leading = 0;
trailing_ = 1;

firstName = "John";
lastName = "Doe";
userAge = 25;
isActive = true;
accountBalance = 1000;

bufferSize = 1024;
maxRetries = 3;
debugMode = false;

// ===============================================
// OPERATORS
// ===============================================

// Arithmetic
add = a + b;
sub = x - y;
mul = m * n;
div = p / q;
mod = r % s;

// Assignment
assign1 = value;
assign2 += 5;
assign3 -= 3;
assign4 *= 2;
assign5 /= 4;
assign6 %= 7;

// Comparison
eq = (a == b);
neq = (c != d);
lt = (e < f);
lte = (g <= h);
gt = (i > j);
gte = (k >= l);

// Logical
and = (cond1 && cond2);
or = (cond3 || cond4);
not = (!cond5);

// ===============================================
// PUNCTUATION
// ===============================================

func1 = myFunc(arg1, arg2, arg3);
group = (a + b) * c;

block = {
    stmt1;
    stmt2;
    stmt3;
};

obj = {key: value, key2: value2};

arr = [x, y, z];
access = array[index];

list = item1, item2, item3;
pair = key: value;

// ===============================================
// COMMENTS
// ===============================================

commentVar = 42; // End of line comment

// Single line comment
// Another comment line

/* Block comment */

/* 
 * Multi-line
 * block comment
 */

inlineVar = /* inline */ 5;

// ===============================================
// COMPLEX EXPRESSIONS
// ===============================================

expr1 = (a + b) * c - d / e % f;
expr2 = x * y + z * w;
expr3 = 2.5 * 3.14159;

bool1 = (x > 0) && (y < 100);
bool2 = !flag1 && (flag2 || flag3);
bool3 = (a != b) && (c <= d);

mixed1 = 0xFF + 0b1010;
mixed2 = 3.14 * 0x10;
mixed3 = 42 - 0o77;

// ===============================================
// REALISTIC FUNCTIONS
// ===============================================

fn factorial(n) {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

fn fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

fn processArray(arr, size) {
    let result = 0;
    for (i = 0; i < size; i += 1) {
        result += arr[i];
    }
    return result;
}

// ===============================================
// DATA STRUCTURES
// ===============================================

coordinates = [x, y, z];
matrix = [[1, 2, 3], [4, 5, 6]];

config = {
    host: "localhost",
    port: 8080,
    secure: true,
    timeout: 30
};

user = {
    name: "Alice",
    age: 30,
    active: true,
    balance: 1500.75
};

// ===============================================
// FINAL VALIDATION
// ===============================================

fn main() {
    let message = "GoLexer Test Complete";
    let version = 1.0;
    let status = true;

    if (status) {
        return message;
    }

    return "Error";
}

finalVar = "All tests passed";